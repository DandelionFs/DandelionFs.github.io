<!doctype html>
<html lang="en-us">

<head>
    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.68.3" />

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Git - @bGZoCg">
    <meta name="twitter:description" content="版本控制系统 —— 记录每次文件的改动，协作编辑，避免管理一堆类似的文件了，也不需要把文件传来传去。
如果想查看某次改动，只需要在软件里瞄一眼就可以，能记录每次文件的改动：
这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。
   版本 文件名 用户 说明 日期     1 service.doc 张三 删除了软件服务条款5 7/12 10:38   2 service.doc 张三 增加了License人数限制 7/12 18:09   3 service.doc 李四 财务部门调整了合同金额 7/13 9:51   4 service.doc 张三 延长了免费升级周期 7/14 15:17   ">
    <meta name="twitter:site" content="https://bgzocg.me/">
    <meta name="twitter:creator" content="">
    <meta name="twitter:image" content="https://dandelionfs.oss-cn-beijing.aliyuncs.com/bgzocg_avator.jpg">
    
    
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Git - @bGZoCg">
    <meta property="og:description" content="版本控制系统 —— 记录每次文件的改动，协作编辑，避免管理一堆类似的文件了，也不需要把文件传来传去。
如果想查看某次改动，只需要在软件里瞄一眼就可以，能记录每次文件的改动：
这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。
   版本 文件名 用户 说明 日期     1 service.doc 张三 删除了软件服务条款5 7/12 10:38   2 service.doc 张三 增加了License人数限制 7/12 18:09   3 service.doc 李四 财务部门调整了合同金额 7/13 9:51   4 service.doc 张三 延长了免费升级周期 7/14 15:17   ">
    <meta property="og:url" content="https://bgzocg.me/git/">
    <meta property="og:site_name" content="@bGZoCg">
    <meta property="og:image" content="https://dandelionfs.oss-cn-beijing.aliyuncs.com/bgzocg_avator.jpg">
    
    <title>Git - @bGZoCg</title>

    <meta name="author" content="bGZoCg">
    <meta name="description" content="版本控制系统 —— 记录每次文件的改动，协作编辑，避免管理一堆类似的文件了，也不需要把文件传来传去。
如果想查看某次改动，只需要在软件里瞄一眼就可以，能记录每次文件的改动：
这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。
   版本 文件名 用户 说明 日期     1 service.doc 张三 删除了软件服务条款5 7/12 10:38   2 service.doc 张三 增加了License人数限制 7/12 18:09   3 service.doc 李四 财务部门调整了合同金额 7/13 9:51   4 service.doc 张三 延长了免费升级周期 7/14 15:17   ">

    
    

    
    

    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Arvo:400,700">
    <link rel="stylesheet" href="https://bgzocg.me/css/theme.css">
    <link rel="stylesheet" href="https://bgzocg.me/css/chroma.dracula.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🌈</text></svg>">
</head>
<body class="font-serif bg-gray-200 border-t-4 border-blue-500 antialiased">
    <div class="w-full p-6 md:w-2/3 md:px-0 md:mx-auto xl:w-2/5">
        <header class="mb-6">
            
            <div class="mb-6 md:flex md:items-center">
                
<div>
    <a class="text-lg mb-8 inline-block" href="/">&larr; Back Home</a>

    
    
    <h1 class="text-4xl font-bold">Git</h1>
    <time datetime="2020-11-06 00:00:00 CST">06 Nov 2020</time>
    
    
    
    <ol class="mt-4">
        
        <li class="inline-block">
            <a class="border-none text-gray-800 text-xs bg-gray-400 hover:bg-gray-600 hover:text-white rounded-sm px-3 py-1" href="https://bgzocg.me/tags/tool">Tool</a>
        </li>
        
    </ol>
    
</div>

            </div>

            
            
        </header>

        
        
<article class="mb-12">
    <p>版本控制系统 —— 记录每次文件的改动，协作编辑，避免管理一堆类似的文件了，也不需要把文件传来传去。</p>
<p>如果想查看某次改动，只需要在软件里瞄一眼就可以，能记录每次文件的改动：</p>
<p>这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>文件名</th>
<th>用户</th>
<th>说明</th>
<th>日期</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>service.doc</td>
<td>张三</td>
<td>删除了软件服务条款5</td>
<td>7/12 10:38</td>
</tr>
<tr>
<td>2</td>
<td>service.doc</td>
<td>张三</td>
<td>增加了License人数限制</td>
<td>7/12 18:09</td>
</tr>
<tr>
<td>3</td>
<td>service.doc</td>
<td>李四</td>
<td>财务部门调整了合同金额</td>
<td>7/13 9:51</td>
</tr>
<tr>
<td>4</td>
<td>service.doc</td>
<td>张三</td>
<td>延长了免费升级周期</td>
<td>7/14 15:17</td>
</tr>
</tbody>
</table>
</br>
</br>
<h2 id="history">History</h2>
<blockquote>
<p>Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。</p>
</blockquote>
<p>Linus 在 1991年 创建了开源的 Linux</p>
<p>2002年前，志愿者把源代码用 <strong>diff</strong> (命令)  的方式发给Linus，后由本人手工合并。</p>
<p>BitKeeper 的东家 BitMover 公司授权 Linux社区 免费使用这个版本控制系统。</p>
<p>2005年 Linux社区牛人聚集 开发Samba的Andrew试图破解BitKeeper的协议，被BitMover公司发现了，收回Linux社区的免费使用权。</p>
<p>Linus 花了两周时间自己用C写了一个分布式版本控制系统——Git！一个月之内，Linux系统的源码已经由Git管理了！</p>
<p>2008年，GitHub上线，为开源项目免费提供 Git 存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p>
<p><strong>[关于 diff 的延拓]：</strong><a href="https://www.zhihu.com/question/295125460/answer/493797867">醉卧沙场的回答 - 知乎</a></p>
<p><br><br></p>
<h2 id="install-git">Install Git</h2>
<ul>
<li>Linux：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git <span class="c1"># 测试一下电脑里面有没有git</span>
sudo apt-get install git <span class="c1"># Debian 或 Ubuntu Linux</span>
sudo apt-get install git-core <span class="c1"># 老版本Debian 或 Ubuntu Linux（避免和一个叫GIT(GNU Interactive Tools)的软件重名）</span>
</code></pre></div><ul>
<li>Win</li>
</ul>
<p>安装完后配置自己的账户</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git config --global user.name <span class="s2">&#34;Your Name&#34;</span>
git config --global user.email <span class="s2">&#34;email@example.com&#34;</span>
<span class="c1"># 检查</span>
git config --global user.name
git config --global user.email
</code></pre></div><p><strong>注：</strong></p>
<p><code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上<strong>所有的Git仓库都会使用这个配置</strong>，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<p><br><br></p>
<h2 id="repo">Repo</h2>
<p>仓库(<strong>Repository</strong>)，版本库，可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
</br>
<p>一个合适的地方，创建一个空目录：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">mkdir text
<span class="nb">cd</span> text
<span class="nb">pwd</span>
</code></pre></div><p>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git init
</code></pre></div><p>可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了(用<code>ls -ah</code>命令就可以看见)。也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。</p>
<p>补：Git配置同时推送到GitHub和码云</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git remote add origin + Url <span class="c1"># 本地初始化需要先添加默认的远程仓库</span>
git remote set-url --add origin + Url <span class="c1"># 配置需要同时推送到的其他仓库添加码云</span>
</code></pre></div><p><br><br></p>
<h2 id="add-sth-into-repo">Add Sth into Repo</h2>
<p>版本控制系统可以告诉你每次的改动，而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>不幸的是，<strong>Microsoft的Word格式是二进制格式</strong>，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，<strong>如果要真正使用版本控制系统，就要以纯文本方式编写文件</strong>。因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议<strong>使用标准的UTF-8编码</strong>，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
</br>
<blockquote>
<p><del>使用Windows的童鞋要特别注意：</del></p>
<p><del><strong>千万不要使用Windows自带的记事本编辑任何文本文件</strong>。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地<strong>在每个文件开头添加了0xefbbbf（十六进制）的字符</strong>，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="http://notepad-plus-plus.org/">Notepad++</a>代替记事本，不但功能强大，而且免费！记得把Notepad++的<strong>默认编码设置为UTF-8 without BOM</strong>即可：</del></p>
</blockquote>
<br>
<p>编写一个<code>readme.txt</code>文件，然后开始试验：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git add readme.txt
git commit -m <span class="s2">&#34;wrote a readme file&#34;</span><span class="c1">#  -m后面输入的是本次提交的说明</span>
git add file1.txt
git add file2.txt file3.txt
git commit -m <span class="s2">&#34;add 3 files.&#34;</span> <span class="c1"># `commit`可以一次提交很多文件，所以你可以多次`add`不同的文件</span>
git status# 时刻掌握仓库当前的状态
git diff readme.txt <span class="c1">#如果你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的; 顾名思义就是查看difference，显示的格式正是Unix通用的diff格式</span>
</code></pre></div><p><br><br></p>
<h3 id="版本回退">版本回退</h3>
<p>Git每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。 版本控制系统帮助我们记得一个几千行的文件每次都改了什么内容。在Git中，我们用<code>git log</code>命令查看：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git log <span class="c1"># (--pretty=oneline) 显示从最近到最远的提交日志;如果嫌输出信息太多，看得眼花缭乱的，可以试试加上</span>
</code></pre></div><p>需要友情提示的是 一大串类似<code>1094adb...</code>的是<code>commit id</code>**（版本号）**，和**SVN**不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字（哈希值），用十六进制表示，具有一致性。</p>
<p>因为<strong>Git是分布式的版本控制系统，我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了</strong>。每提交一个新版本，实际上Git就会把它们自动串成一条时间线。</p>
<p>好了，现在我们准备把<code>readme.txt</code>回退到上一个版本，最早的的那个版本.</p>
<ul>
<li>Git必须知道现在是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git reset --hard HEAD^
cat readme.txt
</code></pre></div><ul>
<li><strong>[Tip1]</strong> : 其实如果你把窗口关掉，想再回去已经回不去了。反之，找到他的哈希值，或者从记忆里找，至少包含前四个值，Git会自动去找。值得注意的是，版本号是自上而下的，就是新的改动先显示</li>
<li><strong>[Tip2]</strong>: Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git reset --hard 1094a
cat readme.txt
</code></pre></div><p><img src="/img/tool/Head%201.png" alt=""><img src="/img/tool/Head%202.png" alt=""></p>
<p>正对于[Tip1]，怎么办？</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git reflog 
<span class="c1"># 记录你的每一次命令；从输出可知append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。</span>
</code></pre></div><br>
<h3 id="工作区--暂存区">工作区 &amp; 暂存区</h3>
<p>Git和其他版本控制系统（如SVN）的一个不同之处就是有暂存区的概念。</p>
<ul>
<li><strong>工作区（Working Directory）</strong>: 就是你在电脑里能看到的目录，比如<code>text</code>文件夹就是一个工作区：</li>
<li><strong>版本库（Repository）</strong>: 工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。版本库里存了很多东西，其中最重要的就是称为**stage（或者叫index）**的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</li>
</ul>
<p><img src="/img/tool/git_resp_remote.jpeg" alt=""></p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<ol>
<li>是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</li>
<li>是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</li>
</ol>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>
</br>
<h3 id="管理修改">管理修改</h3>
<p>Git跟踪并管理的是修改，而非文件。为什么说Git管理的是修改，而不是文件呢？</p>
<p>做实验：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">cat readme.txt# 对readme.txt做一个修改，比如加一行内容
git add readme.txt
git status
cat readme.txt 
git commit -m <span class="s2">&#34;git tracks changes&#34;</span>
git status
</code></pre></div><p>发现第二次的修改没有被提交？原因就是<code>Git add</code>就是追踪每一次的修改，第二次没有追踪，自然提交没有。提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git diff HEAD -- readme.txt 
</code></pre></div><br>
<h3 id="撤销修改">撤销修改</h3>
<h4 id="在暂存区">在暂存区</h4>
<p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在<code>readme.txt</code>中添加了一行：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">cat readme.txt
git status
git checkout -- readme.txt 
<span class="c1"># readme.txt文件在工作区的修改全部撤销，--很重要，没有--，就变成了“切换到另一个分支”的命令。</span>
</code></pre></div><p>这里有两种情况：</p>
<ol>
<li>readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li>
<li>readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li>
</ol>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态，意思就是说如果自你上次改完文件后，如果你的修改全都错误，那么<code>git checkout</code>适合你。</p>
<p><br><br></p>
<h4 id="不在暂存区">不在暂存区</h4>
<p>另外一种Scene，现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">cat readme.txt
git add readme.txt <span class="c1">#在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交</span>
git status <span class="c1"># 此时用命令git reset HEAD可以把暂存区的修改撤销掉（unstage），重新放回工作区</span>
git reset HEAD readme.txt
</code></pre></div><p>注意：此前的版本回退是<code>git reset --hard readme.txt</code>。这时，<code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git status
git checkout -- readme.txt# 丢弃工作区的修改
git status
</code></pre></div><h4 id="存在于版本库">存在于版本库</h4>
<p>最糟糕的是现在你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？</p>
<p>还记得版本回退吗？可以回退到上一个版本。不过，这是有条件的，就是<strong>你还没有把自己的本地版本库推送到远程</strong>。还记得Git是分布式版本控制系统吗？一旦你提交推送到远程版本库，下个公司再见……</p>
<center><font color="red">这教会你在代码提交到远程库的时候千万千万多看两眼，仅仅为了活下去</font></center>
<br>
<h3 id="删除文件">删除文件</h3>
<p>Git中删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git add test.txt
git commit -m <span class="s2">&#34;add test.txt&#34;</span>
rm test.txt <span class="c1"># 此时工作区和版本库就不一致了</span>
git status <span class="c1"># 这个时候，Git知道你删除了文件，因此，，`git status`命令会立刻告诉你哪些文件被删除了</span>
</code></pre></div><p>现在你有两个选择：</p>
<ul>
<li>确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git rm test.txt# 意思是删除资源库里面的存档，效果是个git add差不多的
rm <span class="s1">&#39;test.txt&#39;</span><span class="c1"># 或者手动删除文件效果是一样</span>
git commit -m <span class="s2">&#34;remove test.txt&#34;</span><span class="c1"># 提交这次的修改OKAY</span>
</code></pre></div><ul>
<li>删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本，因此你会<strong>最近一次提交后你修改的内容</strong>：</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git checkout -- test.txt# 用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”
</code></pre></div><center><font color="red"> 从来没有被添加到版本库就被删除的文件，是无法恢复的！  </font></center>
<p><br><br></p>
<h2 id="git-sever">Git Sever</h2>
<p>SVN: 这些功能在SVN里早就有了，没看出Git有什么特别的地方。</p>
<p>没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。但是<strong>远程仓库</strong>就是一个点。Git是分布式版本控制系统，<strong>同一个Git仓库，可以分布到不同的机器上。怎么分布呢？</strong></p>
<blockquote>
<p>最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库（???怎么做???）。实际情况往往是服务器充当中间的媒介。</p>
</blockquote>
<br>
<p>完全可以自己搭建一台运行Git的服务器，而<a href="https://github.com/">GitHub</a>网站提供Git仓库托管服务的，由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以需要一点设置(Github 拿到你电脑的公钥)。 为什么GitHub需要SSH Key呢？</p>
<blockquote>
<p><strong>因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送</strong>。当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，<strong>只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了</strong>。最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p>
</blockquote>
<br>
<h3 id="添加远程库">添加远程库</h3>
<p>现在我们根据GitHub的提示，在本地的仓库下运行命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git remote add origin git@github.com:youraccountname/yourreponame .git <span class="c1">#远程库的名字就是`origin`，这是Git默认的叫法，也可以改成别的</span>
git push -u origin master# 把本地库的所有内容推送到远程库上，由于远程库是空的，第一次推送分支时，有了 -u
</code></pre></div><p>Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。从现在起，只要本地作了提交，就可以通过命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git push origin master# 把本地<span class="sb">`</span>master<span class="sb">`</span>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！
</code></pre></div><p><font color="red">SSH Worning: </font>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established.</span>
<span class="c1"># RSA key fingerprint is xx.xx.xx.xx.xx.</span>
<span class="c1"># Are you sure you want to continue connecting (yes/no)?</span>
</code></pre></div><p><strong>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可</strong>。Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了，这个警告只会出现一次，后面的操作就不会有任何警告了：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Warning: Permanently added &#39;github.com&#39; (RSA) to the list of known hosts.</span>
</code></pre></div><p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p>
<br>
<h3 id="从远程库克隆">从远程库克隆</h3>
<p>Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。使用<code>https</code>除了速度慢以外（大陆除外），还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。
<br><br></p>
<h2 id="master-commit">Master Commit</h2>
<blockquote>
<p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p>
</blockquote>
<p>其他版本控制系统如SVN创建和切换分支比蜗牛还慢。</p>
<br>
<h3 id="创建与合并分支">创建与合并分支</h3>
<p>版本回退的每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p>
<p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p>
<p><img src="/img/tool/Git_Pointer.png" alt=""></p>
<p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p>
<p><img src="/img/tool/l.png" alt=""></p>
<p>你看，Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p>
<p><img src="/img/tool/git_pointermv.png" alt=""></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：
<img src="/img/tool/Git__P.png" alt=""></p>
<p>真是太神奇了，你看得出来有些提交是通过分支完成的吗？下面开始:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git checkout -b dev <span class="c1"># 创建dev分支，然后切换到`dev`分支; 加上`-b`参数表示创建并切换，相当于以下两条命令:</span>
<span class="c1"># git branch dev</span>
<span class="c1"># git checkout dev</span>
git branch <span class="c1"># 列出所有分支，当前分支前面会标一个*号</span>
</code></pre></div><p>我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改然后提交：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git add readme.txt 
git commit -m <span class="s2">&#34;branch test&#34;</span>
git checkout master# 切换回master分支<span class="p">;</span> 之后查看原来提交分支的内容其实并没有变化
git merge dev# dev分支合并
git branch -d dev# 删除dev分支
git branch# 只剩下master分支
</code></pre></div><p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。当然，也不是每次合并都能<code>Fast-forward</code>, 参考后面的 。因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p>
</br>
<h3 id="冲突">冲突</h3>
<p>一个场景：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git switch -c feature1 <span class="c1"># Switched to a new branch &#39;feature1&#39; # 修改文件</span>
git add readme.txt <span class="c1"># 在feature1分支上提交：</span>
git commit -m <span class="s2">&#34;AND simple&#34;</span>
git switch master# 切换到master分支, 修改文件：
git add readme.txt 
git commit -m <span class="s2">&#34;&amp; simple&#34;</span>
</code></pre></div><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，冲突发生:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git merge feature1
git status
cat <span class="s2">&#34;readme.txt&#34;</span> <span class="c1">#Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容；我们修改如下后保存：`Creating a new branch is quick and simple.`</span>
git add readme.txt 
git commit -m <span class="s2">&#34;conflict fixed&#34;</span>
git log --graph --pretty<span class="o">=</span>oneline --abbrev-commit
<span class="c1"># git log --graph`命令可以看到分支合并图</span>
<span class="c1"># *   cf810e4 (HEAD -&gt; master) conflict fixed</span>
<span class="c1"># |\</span>  
<span class="c1"># | * 14096d0 (feature1) AND simple</span>
<span class="c1"># * | 5dc6824 &amp; simple</span>
<span class="c1"># |/</span>  
git branch -d feature1# 删除feature1分支：
</code></pre></div><p>Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是<strong>把Git合并失败的文件手动编辑为我们希望的内容，再提交。</strong></p>
<br>
<h3 id="分支管理策略">分支管理策略</h3>
<p><code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息，如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息，这时可以用<code>--no-ff</code>方式的<code>git merge</code>.q其实加上<code>--no-ff</code>参数就可以<strong>用普通模式合并</strong>，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git switch -c dev# 创建并切换dev分支
git add readme.txt <span class="c1">#修改后提交非分支</span>
git commit -m <span class="s2">&#34;add merge&#34;</span>
git switch master# 切换回master
git merge --no-ff -m <span class="s2">&#34;merge with no-ff&#34;</span> dev# 合并要创建一个新commit，故+ -m参数
git log --graph --pretty<span class="o">=</span>oneline --abbrev-commit
<span class="c1"># *   e1e9c68 (HEAD -&gt; master) merge with no-ff</span>
<span class="c1"># |\</span>  
<span class="c1"># | * f52c633 (dev) add merge</span>
<span class="c1"># |/</span>  
<span class="c1"># *   cf810e4 conflict fixed</span>
</code></pre></div><p><img src="/img/tool/git_branch_manage.png" alt=""></p>
<p>所以最后下来是这样做的：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。所以，团队合作的分支看起来就像这样：</p>
<p><img src="/img/tool/Git_line.png" alt=""></p>
<br>
<h3 id="bug分支--stash-保存现场">Bug分支&ndash;Stash 保存现场</h3>
<p>在Git中分支是如此的强大，所以每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交：</p>
<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git stash
git status <span class="c1"># 查看工作区，就是干净的（除非有没有被Git管理的文件）确定要在哪个分支上修复bug，假定需要在 master 分支上修复，就从`master`创建临时分支：</span>
git checkout master
git checkout -b issue-101 
git add readme.txt 
git commit -m <span class="s2">&#34;fix bug 101&#34;</span>
git switch master
git merge --no-ff -m <span class="s2">&#34;merged bug fix 101&#34;</span> issue-101 <span class="c1"># 完成合并，最后删除issue-101分支</span>
git switch dev#切回去继续干活
git status
git stash list
</code></pre></div><p>恢复有两个办法：</p>
<ol>
<li><code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</li>
<li><code>git stash pop</code>，恢复的同时把stash内容也删了：</li>
</ol>
<p>可以多次stash，恢复的时候用<code>git stash list</code>查看，然后恢复指定的stash：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git stash pop
git stash list
git stash apply stash@<span class="o">{</span>0<span class="o">}</span>
</code></pre></div><p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。那怎么在dev分支上修复同样的bug？</p>
<p>重复操作一次，提交不就行了？</p>
<p>有更简单的方法。同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。为了方便操作，Git专供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git branch
git cherry-pick 4c805e2
</code></pre></div><p>Git自动给dev分支做了一次提交，<strong>注意这次提交的commit是<code>1d4b803</code></strong>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p>
<p>既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？</p>
<p>当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从dev分支切换到master分支。即在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick </code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
</br>
<h3 id="delete分支">Delete分支</h3>
<p>添加一个新功能时，你会每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。但是突然接到上级命令，因经费不足，新功能必须取消！</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git switch -c feature-vulcan
git add vulcan.py
git status
git commit -m <span class="s2">&#34;add feature vulcan&#34;</span>
git switch dev
git branch -d feature-vulcan# Error
git branch -D feature-vulcan# 强行删除
</code></pre></div><br>
<h3 id="多人协作">多人协作</h3>
<p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"> git remote <span class="o">(</span>-v<span class="o">)</span><span class="c1"># 显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址</span>  
 git push origin XXX
</code></pre></div><br>
<h3 id="rebase---变基">Rebase -&gt; 变基</h3>
<p>拉去远程的仓库和自己的仓库后准备提交, 有冲突的可以用前面的命令存一下.</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">git log --graph --pretty<span class="o">=</span>oneline --abbrev-commit <span class="c1"># 查看历史</span>
git rebase <span class="c1"># 看上去更直观, 缺点是本地的分叉提交的哈希值已经被修改过了(?)</span>
</code></pre></div><p><br><br></p>
<h2 id="标签管理">标签管理</h2>
<p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。其实它就是指向某个commit的指针. 创建和删除标签都是瞬间完成的。</p>
<h3 id="创建标签">创建标签</h3>
<p>命令<code>git tag </code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git tag v1.0.0 1094adb
git tag -a v0.1 -m <span class="s2">&#34;version 0.1 released&#34;</span> <span class="c1"># 可以指定标签信息，``-a`指定标签名，`-m`指定说明文字;</span>
git tag# 查看所有标签
git show v0.9 <span class="c1">#查看标签的详细信息</span>
</code></pre></div><br>
<h3 id="操作标签">操作标签</h3>
<p>创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。如果要推送某个标签到远程，使用命令<code>git push origin </code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">git tag -d v0.1
git push origin v1.0
git push origin --tags
git tag -d v0.9 <span class="c1">#删除远程标签</span>
git push origin :refs/tags/v0.9
</code></pre></div><br>
<h2 id="提升git-clone-速度的git命令">提升Git Clone 速度的Git命令</h2>
<p>明明Git提交分支的时候速度可以上2Mib/s，但是Clone的时候就奇慢无比……佛了</p>
<h3 id="梯子">梯子</h3>
<p>用SSh无用，对比如下，可能是我的SS不太好用……</p>
<p><img src="http://i.dfslfh.cn/comper_github.png" alt=""></p>
<p>用Git代理默认SS的1080端口，花个好价钱买个好机子……</p>
<div class="highlight"><pre class="chroma"><code class="language-nginx" data-lang="nginx"><span class="k">git</span> <span class="s">config</span> <span class="s">--global</span> <span class="s">http.https://github.com.proxy</span> <span class="s">socks5://127.0.0.1:1080</span> <span class="c1"># 只对 github.com
</span><span class="c1"></span><span class="s">git</span> <span class="s">config</span> <span class="s">--global</span> <span class="s">--unset</span> <span class="s">http.https://github.com.proxy</span> <span class="c1"># 取消代理
</span></code></pre></div><h3 id="码云">码云</h3>
<p>无脑关联Github，然后导入自己的仓库，从Github下面直接Clone ，缺点就是暂时不确定Pull到Github是否正确提交……</p>
<p>速度你根本无法想象，工具人<a href="https://gitee.com">码云</a>了解一下</p>
<p><img src="http://i.dfslfh.cn/gitee.png" alt=""></p>
</br>
<h2 id="后记">后记</h2>
<ul>
<li>在Clone一个300+M的项目的时候，出现了<code>git clone: error: RPC failed;The remote end hung up unexpectedlyfatal: The remote end hung up unexpectedly Everything up-to-dat</code>的错误，好像是因为curl的postBuffer 默认值较小的原因,配置下个这个值,就不会出现该错误了.
<ul>
<li>
<pre><code>git config http.postBuffer 524288000=
</code></pre></li>
<li>50G左右，应该没有问题了，我不信代码给我写了一个云盘……
然后再次Clone就没有这个问题了……</li>
</ul>
</li>
<li>其实感觉有的时候中国的教材不是给下面的人看的，而是给同僚和自己看的，我会嫌弃写的过于详细而浪费时间，但是当我在拜读那些大佬的作品的时候常常因为他们的“此处省略”而抓耳挠腮……
<ul>
<li>git remote：列出remote 别名。</li>
<li>git remote rm [别名]: 删除一个存在的remote alias。</li>
<li>git remote set-url [别名] [url]:更新远程repo的url。</li>
<li>git branch：列出本地所有分支,当前分支会被星号标示出。</li>
<li>git branch (branchname): 创建一个新的分支(当你用这种方式创建分支的时候,分支是基于你的上一次提交建立的)。</li>
<li>git config -l：查看git config的信息</li>
<li>git push -f：强推（慎用），即利用强覆盖方式用你本地的代码替代git仓库内的内容</li>
</ul>
</li>
</ul>
<br>
<h2 id="reference">Reference</h2>
<p>[1]. <a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的官方网站的Git教程</a> : 教程事无巨细且读来有趣不乏味，推荐原文阅读。</p>
<p>[2]. <a href="https://git-scm.com/book/zh/v2">Git-Book</a>:Git的官方文档，可以随时查看。如果需要官方书籍请点击<a href="http://pan-yz.chaoxing.com/share/info/1798800a2d238b41">这里</a>.</p>
<p>[3]. 要方便管理公钥，用Gitosis；要像SVN那样变态地控制权限，用Gitolite。 搭建Git服务器参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664">这个</a></p>
<p>[4]. <a href="https://www.zhihu.com/question/27159393">知乎-git clone一个github上的仓库，太慢，经常连接失败，但是github官网流畅访问，为什么？</a>.</p>
<p>[5]. <a href="https://www.v2ex.com/t/574303">V2ex- github 克隆速度慢无止境，最近被此问题困扰浪费太多时间</a>.</p>
<p>[6]. <a href="https://blog.51cto.com/11887934/2051323">修改Host</a></p>
<p>[7]. <a href="https://blog.darkthread.net/blog/git-author-n-committer/">Git 筆記 - 作者(Auhtor)與提交者(Commmitter)差異實驗</a></p>

    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "bgzocg" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</article>


        <footer>
            <p>
            &copy; 2021.   <a href=./index.xml> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon" style="width:1em;height:1em;fill:white;"><path d="M19.199 24C19.199 13.467 10.533 4.8 0 4.8V0c13.165 0 24 10.835 24 24h-4.801zM3.291 17.415c1.814 0 3.293 1.479 3.293 3.295 0 1.813-1.485 3.29-3.301 3.29C1.47 24 0 22.526 0 20.71s1.475-3.294 3.291-3.295zM15.909 24h-4.665c0-6.169-5.075-11.245-11.244-11.245V8.09c8.727 0 15.909 7.184 15.909 15.91z"/></svg></a>
            </p>
        </footer>
    </div>

    
</body>
</html>
